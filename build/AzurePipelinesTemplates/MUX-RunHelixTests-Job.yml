parameters:
  name: 'RunTestsInHelix'
  dependsOn: ''
  condition: ''
  testSuite: ''
  maxParallel: 4
  matrix: 
    Release_x86:
      buildPlatform: 'x86'
      buildConfiguration: 'release'
      # %3b is the escape code for ';' which is used as the delimiter
      helixTargetQueues: 'Windows.10.Amd64.ClientRS3.DevEx.Open%3bWindows.10.Amd64.ServerRS5.Open'
    Release_x64:
      buildPlatform: 'x64'
      buildConfiguration: 'release'
      helixTargetQueues: 'Windows.10.Amd64.ClientRS2.Open%3bWindows.10.Amd64.ClientRS4.Open'

jobs:
- job: ${{ parameters.name }}
  dependsOn: ${{ parameters.dependsOn }}
  condition: ${{ parameters.condition }}
  pool:
    vmImage: 'VS2017-Win2016'
  timeoutInMinutes: 120
  variables:
    artifactsDir: $(Build.SourcesDirectory)\Artifacts
    taefPath: $(Build.SourcesDirectory)\build\Helix\packages\taef.redist.wlk.10.31.180822002\build\Binaries\$(buildPlatform)
  strategy:
    maxParallel: ${{ parameters.maxParallel }}
    matrix: ${{ parameters.matrix }}
      
  steps:
  - task: CmdLine@1
    displayName: 'Display build machine environment variables'
    inputs:
      filename: 'set'
      
  - task: NuGetToolInstaller@0
    displayName: 'Use NuGet 4.9.3'
    inputs:
      versionSpec: 4.9.3

  - task: 333b11bd-d341-40d9-afcf-b32d5ce6f23b@2
    displayName: 'NuGet restore build/Helix/packages.config'
    inputs:
      restoreSolution: build/Helix/packages.config
      feedsToUse: config
      nugetConfigPath: nuget.config
      restoreDirectory: packages

  - task: DownloadBuildArtifacts@0 
    condition:
      eq(variables['useBuildOutputFromBuildId'],'') 
    inputs: 
      artifactName: drop 
      downloadPath: '$(artifactsDir)'

  - task: DownloadBuildArtifacts@0 
    condition:
      ne(variables['useBuildOutputFromBuildId'],'') 
    inputs: 
      buildType: specific
      buildVersionToDownload: specific
      project: $(System.TeamProjectId)
      pipeline: $(System.DefinitionId)
      buildId: $(useBuildOutputFromBuildId)
      artifactName: drop 
      downloadPath: '$(artifactsDir)'

  - task: powershell@2
    displayName: 'PrepareHelixPayload.ps1'
    inputs:
      targetType: filePath
      filePath: build\Helix\PrepareHelixPayload.ps1
      arguments: -Platform '$(buildPlatform)' -Configuration '$(buildConfiguration)'
      
  - task: CmdLine@1
    displayName: 'Display Helix payload contents'
    inputs:
      filename: 'dir'
      arguments: '/s $(Build.SourcesDirectory)\HelixPayload'

  - template: MUX-CreateHelixProjFile-Steps.yml
    parameters:
      condition: ne('${{ parameters.testSuite }}','NugetTestSuite')
      testFilePath: '$(artifactsDir)\drop\$(buildConfiguration)\$(buildPlatform)\Test\MUXControls.Test.dll'
      outputProjFileName: 'RunTestsInHelix-InteractionTests.proj'
      testSuite: '${{ parameters.testSuite }}'

  - template: MUX-CreateHelixProjFile-Steps.yml
    parameters:
      condition: ne('${{ parameters.testSuite }}','NugetTestSuite')
      testFilePath: '$(artifactsDir)\drop\$(buildConfiguration)\$(buildPlatform)\AppxPackages\MUXControlsTestApp_Test\MUXControlsTestApp.appx'
      outputProjFileName: 'RunTestsInHelix-ApiTests.proj'
      testSuite: '${{ parameters.testSuite }}'

  - template: MUX-CreateHelixProjFile-Steps.yml
    parameters:
      condition: ne('${{ parameters.testSuite }}','NugetTestSuite')
      testFilePath: '$(artifactsDir)\drop\$(buildConfiguration)\$(buildPlatform)\AppxPackages\IXMPTestApp_Test\IXMPTestApp.appx'
      outputProjFileName: 'RunTestsInHelix-IXMPTestAppTests.proj'
      testSuite: '${{ parameters.testSuite }}'

  - template: MUX-CreateHelixProjFile-Steps.yml
    parameters:
      condition: eq('${{ parameters.testSuite }}','NugetTestSuite')
      testFilePath: '$(artifactsDir)\drop\$(buildConfiguration)\$(buildPlatform)\Test\MUXControls.ReleaseTest.dll'
      outputProjFileName: 'RunTestsInHelix-NugetTests.proj'
      testSuite: '${{ parameters.testSuite }}'

  - task: PublishBuildArtifacts@1
    displayName: 'Publish generated .proj files'
    inputs:
      PathtoPublish: $(Build.ArtifactStagingDirectory)
      artifactName: 'drop'
      
  - task: DotNetCoreCLI@2
    displayName: 'Run tests in Helix'
    continueOnError: true
    env:
      SYSTEM_ACCESSTOKEN: $(System.AccessToken)
    inputs:
      command: custom
      projects: build\Helix\RunTestsInHelix.proj
      custom: msbuild
      arguments: '/binaryLogger:$(Build.SourcesDirectory)/${{parameters.name}}.$(buildPlatform).$(buildConfiguration).binlog /p:Creator=WinUI /p:IsExternal=true /p:HelixBuild=$(Build.BuildId).$(buildPlatform).$(buildConfiguration) /p:Platform=$(buildPlatform) /p:Configuration=$(buildConfiguration) /p:HelixTargetQueues=$(helixTargetQueues) /p:TestSuite=${{parameters.testSuite}} /p:ProjFilesPath=$(Build.ArtifactStagingDirectory)'
      
  - task: DotNetCoreCLI@2
    displayName: 'Re-run tests in Helix'
    condition: succeededOrFailed()
    enabled: false
    env:
      SYSTEM_ACCESSTOKEN: $(System.AccessToken)
    inputs:
      command: custom
      projects: build\Helix\RunTestsInHelix.proj
      custom: msbuild
      arguments: '/binaryLogger:$(Build.SourcesDirectory)/${{parameters.name}}.$(buildPlatform).$(buildConfiguration).binlog /p:Creator=WinUI /p:IsExternal=true /p:HelixBuild=$(Build.BuildId).$(buildPlatform).$(buildConfiguration) /p:Platform=$(buildPlatform) /p:Configuration=$(buildConfiguration) /p:HelixTargetQueues=$(helixTargetQueues) /p:TestSuite=${{parameters.testSuite}} /p:ProjFilesPath=$(Build.ArtifactStagingDirectory)'

  - task: PublishBuildArtifacts@1
    displayName: 'Publish ${{parameters.name}} binlog'
    condition: succeededOrFailed()
    inputs:
      PathtoPublish: $(Build.SourcesDirectory)/${{parameters.name}}.$(buildPlatform).$(buildConfiguration).binlog
      artifactName: 'drop'

- job: UpdateTests
  dependsOn: ${{ parameters.name }}
  condition: in(dependencies.${{ parameters.name }}.result, 'Succeeded', 'SucceededWithIssues')
  pool:
    vmImage: 'VS2017-Win2016'
  timeoutInMinutes: 120

  steps:
  - checkout: none
  
  - powershell: |
      Write-Host "TestWriteAccessToken: $($env:TESTWRITEACCESSTOKEN)"
      
      $azureDevOpsRestApiHeaders = @{
        "Accept"="application/json"
        "Authorization"="Basic $([System.Convert]::ToBase64String([System.Text.ASCIIEncoding]::ASCII.GetBytes(":$($env:TESTWRITEACCESSTOKEN)")))"
      }
      
      Write-Host "Invoke-RestMethod -Uri `"https://dev.azure.com/ms/microsoft-ui-xaml/_apis/test/runs?buildUri=$($env:BUILD_BUILDURI)`" -Method Get -Headers $azureDevOpsRestApiHeaders"
      Invoke-RestMethod -Uri "https://dev.azure.com/ms/microsoft-ui-xaml/_apis/test/runs?buildUri=$($env:BUILD_BUILDURI)" -Method Get -Headers $azureDevOpsRestApiHeaders
      $testRuns = Invoke-RestMethod -Uri "https://dev.azure.com/ms/microsoft-ui-xaml/_apis/test/runs?buildUri=$($env:BUILD_BUILDURI)" -Method Get -Headers $azureDevOpsRestApiHeaders
      
      $testRuns.value | ForEach-Object {
        $testRun = $_
        $testRunResultsUri = "$($testRun.url)/results?api-version=5.0"
        
        Write-Host "Invoke-RestMethod -Uri `"$($testRun.url)/results?api-version=5.0`" -Method Get -Headers $azureDevOpsRestApiHeaders"
        Invoke-RestMethod -Uri $testRunResultsUri -Method Get -Headers $azureDevOpsRestApiHeaders
        $testResults = Invoke-RestMethod -Uri "$($testRun.url)/results?api-version=5.0" -Method Get -Headers $azureDevOpsRestApiHeaders
        
        $testResults.value | ForEach-Object {
          $testResult = $_
          Write-Host "Test $($testResult.testCaseTitle) : $($testResult.outcome)"
          
          if ($testResult.outcome -eq "NotExecuted" -and $testResult.errorMessage -eq "PassedOnRerun")
          {
            Write-Host "(Actually passed on re-run. Updating.)"
            
            $updateBody = ConvertTo-Json @(@{ "id" = $testResult.id; "outcome" = "PassedOnRerun"; "errorMessage" = ""})
            Write-Host "Invoke-RestMethod -Uri $testRunResultsUri -Method Patch -Headers $azureDevOpsRestApiHeaders -Body $updateBody -ContentType `"application/json-patch+json`""
            Write-Host "`$updateBody:"
            $updateBody
            Invoke-RestMethod -Uri $testRunResultsUri -Method Patch -Headers $azureDevOpsRestApiHeaders -Body $updateBody -ContentType "application/json-patch+json"
          }
        }
      }
      
    displayName: 'Dump test results thus far'
    condition: succeededOrFailed()
    env:
      TESTWRITEACCESSTOKEN: $(TestWriteAccessToken)